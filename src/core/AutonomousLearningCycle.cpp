#include "core/AutonomousLearningCycle.h"
#include "core/HypergraphBrain.h"
#include "core/AutonomousScheduler.h"
#include <algorithm>
#include <numeric>
#include <random>
#include <sstream>

namespace NeuroForge {
namespace Core {

AutonomousLearningCycle::AutonomousLearningCycle(std::shared_ptr<HypergraphBrain> brain,
                                               std::shared_ptr<SubstrateTaskGenerator> task_generator,
                                               const Config& config)
    : brain_(brain)
    , task_generator_(task_generator)
    , config_(config)
    , last_assessment_time_(std::chrono::steady_clock::now()) {
}

bool AutonomousLearningCycle::initialize() {
    if (!brain_ || !task_generator_) {
        return false;
    }
    
    is_active_.store(true);
    cycle_count_.store(0);
    
    // Initialize scaffold elimination tracking
    initializeScaffoldTracking();
    
    // Establish baseline performance
    baseline_performance_ = monitorPerformanceDuringElimination();
    
    // Initialize autonomy metrics
    updateAutonomyMetrics();
    
    return true;
}

void AutonomousLearningCycle::shutdown() {
    is_active_.store(false);
}

bool AutonomousLearningCycle::executeAutonomousCycle(float delta_time) {
    if (!is_active_.load()) {
        return false;
    }
    
    std::uint64_t current_cycle = cycle_count_.fetch_add(1);
    
    // Periodic autonomy assessment and scaffold elimination
    if (current_cycle % config_.autonomy_assessment_interval == 0) {
        float autonomy_level = assessAndEliminateScaffolds();
        
        // Update metrics
        updateAutonomyMetrics();
        
        // Validate performance maintenance
        if (!validatePerformanceMaintenance()) {
            // Temporarily re-enable some scaffolds if performance drops too much
            // This provides a safety mechanism during transition
            return false;
        }
    }
    
    // Generate self-directed learning objectives
    if (config_.enable_self_curriculum) {
        generateSelfCurriculum();
    }
    
    // Implement curiosity-driven exploration
    if (config_.enable_curiosity_driven_exploration) {
        implementCuriosityDrivenExploration();
    }
    
    // Execute substrate-driven task generation
    if (task_generator_) {
        task_generator_->generateTasks(delta_time);
    }
    
    // Implement self-assessment
    implementSelfAssessment();
    
    return true;
}

float AutonomousLearningCycle::assessAndEliminateScaffolds() {
    std::lock_guard<std::mutex> lock(metrics_mutex_);
    
    float total_autonomy = 0.0f;
    std::size_t scaffold_count = 0;
    
    // Assess each scaffold type for elimination
    for (auto& scaffold_pair : scaffold_elimination_status_) {
        ScaffoldType scaffold_type = scaffold_pair.first;
        bool& eliminated = scaffold_pair.second;
        
        if (!eliminated) {
            // Attempt to eliminate this scaffold
            if (eliminateScaffold(scaffold_type)) {
                eliminated = true;
            }
        }
        
        if (eliminated) {
            total_autonomy += 1.0f;
        }
        scaffold_count++;
    }
    
    float autonomy_level = scaffold_count > 0 ? total_autonomy / scaffold_count : 0.0f;
    metrics_.current_autonomy_level = autonomy_level;
    metrics_.scaffold_elimination_progress = autonomy_level;
    
    return autonomy_level;
}

bool AutonomousLearningCycle::eliminateScaffold(ScaffoldType scaffold_type) {
    switch (scaffold_type) {
        case ScaffoldType::TeacherGuidance:
            return eliminateTeacherDependency();
            
        case ScaffoldType::ExternalRewards:
            return replaceExternalRewardsWithIntrinsic();
            
        case ScaffoldType::ScriptedScenarios:
            // Replace scripted scenarios with substrate-generated scenarios
            return generateSelfCurriculum() > 0;
            
        case ScaffoldType::HandCraftedGoals:
            // Replace with substrate-generated adaptive goals
            if (task_generator_) {
                return task_generator_->generateAdaptiveGoal() != 0;
            }
            return false;
            
        case ScaffoldType::ExternalCurriculum:
            return config_.enable_self_curriculum;
            
        case ScaffoldType::PerformanceEvaluation:
            return createAutonomousEvaluationSystem();
            
        case ScaffoldType::TaskSpecification:
            // Tasks now generated by substrate
            return task_generator_ != nullptr;
            
        case ScaffoldType::EnvironmentalSetup:
            // Environment adaptation handled by substrate
            return true;
            
        default:
            return false;
    }
}

std::size_t AutonomousLearningCycle::generateSelfCurriculum() {
    if (!brain_) return 0;
    
    // Generate curriculum based on substrate state and learning progress
    auto intrinsic_objectives = generateIntrinsicObjectives();
    
    std::size_t new_items = 0;
    for (const auto& objective : intrinsic_objectives) {
        // Add to self-generated curriculum if not already present
        if (std::find(self_generated_curriculum_.begin(), 
                     self_generated_curriculum_.end(), 
                     objective) == self_generated_curriculum_.end()) {
            self_generated_curriculum_.push_back(objective);
            new_items++;
        }
    }
    
    return new_items;
}

float AutonomousLearningCycle::implementCuriosityDrivenExploration() {
    if (!brain_ || !task_generator_) return 0.0f;
    
    // Generate exploration tasks based on curiosity and uncertainty
    auto exploration_task_id = task_generator_->generateExplorationTask();
    
    if (exploration_task_id != 0) {
        // Measure exploration effectiveness based on learning outcomes
        float uncertainty_before = task_generator_->calculateUncertaintyLevel();
        
        // Execute exploration (this would be handled by the scheduler)
        // For now, we simulate the exploration effect
        
        float uncertainty_after = task_generator_->calculateUncertaintyLevel();
        float exploration_effectiveness = std::max(0.0f, uncertainty_before - uncertainty_after);
        
        return exploration_effectiveness;
    }
    
    return 0.0f;
}

bool AutonomousLearningCycle::replaceExternalRewardsWithIntrinsic() {
    if (!brain_) return false;
    
    auto* learning_system = brain_->getLearningSystem();
    if (!learning_system) return false;
    
    // Disable external reward pathways and enable intrinsic motivation
    // This would involve modifying the learning system configuration
    
    // Calculate intrinsic motivation dominance
    float intrinsic_dominance = calculateIntrinsicMotivationDominance();
    
    // Consider external rewards eliminated if intrinsic motivation dominates
    return intrinsic_dominance > 0.8f;
}

bool AutonomousLearningCycle::eliminateTeacherDependency() {
    if (!brain_) return false;
    
    // Eliminate dependency on external teacher by:
    // 1. Disabling teacher-driven learning scenarios
    // 2. Enabling self-teaching mechanisms
    // 3. Using substrate-generated learning targets
    
    // Check if substrate can generate its own learning targets
    if (task_generator_) {
        // Generate self-teaching tasks
        auto self_teaching_task = task_generator_->generateSelfReflectionTask();
        return self_teaching_task != 0;
    }
    
    return false;
}

bool AutonomousLearningCycle::createAutonomousEvaluationSystem() {
    if (!brain_) return false;
    
    // Create substrate-driven performance evaluation
    // This involves using intrinsic metrics rather than external benchmarks
    
    auto* learning_system = brain_->getLearningSystem();
    if (!learning_system) return false;
    
    // Use substrate-derived competence metrics
    float competence_level = learning_system->getCompetenceLevel();
    float intrinsic_motivation = task_generator_ ? 
        task_generator_->calculateIntrinsicMotivation() : 0.0f;
    
    // Autonomous evaluation based on internal metrics
    return competence_level > 0.5f && intrinsic_motivation > 0.3f;
}

float AutonomousLearningCycle::monitorPerformanceDuringElimination() {
    if (!brain_) return 0.0f;
    
    auto* learning_system = brain_->getLearningSystem();
    if (!learning_system) return 0.0f;
    
    // Monitor key performance indicators
    float competence = learning_system->getCompetenceLevel();
    float learning_rate = learning_system->getConfig().global_learning_rate;
    float intrinsic_motivation = task_generator_ ? 
        task_generator_->calculateIntrinsicMotivation() : 0.0f;
    
    // Composite performance metric
    float performance = (competence * 0.5f) + (learning_rate * 0.3f) + (intrinsic_motivation * 0.2f);
    
    // Add to performance history
    std::lock_guard<std::mutex> lock(metrics_mutex_);
    performance_history_.push_back(performance);
    
    // Keep only recent history (last 100 measurements)
    if (performance_history_.size() > 100) {
        performance_history_.erase(performance_history_.begin());
    }
    
    return performance;
}

float AutonomousLearningCycle::calculateIntrinsicMotivationDominance() const {
    if (!task_generator_) return 0.0f;
    
    float intrinsic_motivation = task_generator_->calculateIntrinsicMotivation();
    
    // Calculate ratio of intrinsic vs external motivation
    // For now, we assume external motivation is inverse of intrinsic
    float external_motivation = 1.0f - intrinsic_motivation;
    
    if (intrinsic_motivation + external_motivation > 0.0f) {
        return intrinsic_motivation / (intrinsic_motivation + external_motivation);
    }
    
    return 0.0f;
}

float AutonomousLearningCycle::calculateSelfInitiatedTaskRatio() const {
    if (!brain_) return 0.0f;
    
    auto* scheduler = brain_->getAutonomousScheduler();
    if (!scheduler) return 0.0f;
    
    auto stats = scheduler->getStatistics();
    
    // Calculate ratio of self-initiated vs externally-initiated tasks
    std::uint64_t total_tasks = stats.total_tasks_completed + stats.total_tasks_failed;
    if (total_tasks == 0) return 0.0f;
    
    // For now, assume all completed tasks are self-initiated
    // In a full implementation, we would track task origins
    return static_cast<float>(stats.total_tasks_completed) / total_tasks;
}

bool AutonomousLearningCycle::isFullyAutonomous() const {
    std::lock_guard<std::mutex> lock(metrics_mutex_);
    return metrics_.current_autonomy_level >= config_.autonomy_target;
}

float AutonomousLearningCycle::getScaffoldEliminationProgress() const {
    std::lock_guard<std::mutex> lock(metrics_mutex_);
    return metrics_.scaffold_elimination_progress;
}

void AutonomousLearningCycle::initializeScaffoldTracking() {
    // Initialize all scaffold types as not eliminated
    scaffold_elimination_status_[ScaffoldType::TeacherGuidance] = false;
    scaffold_elimination_status_[ScaffoldType::ExternalRewards] = false;
    scaffold_elimination_status_[ScaffoldType::ScriptedScenarios] = false;
    scaffold_elimination_status_[ScaffoldType::HandCraftedGoals] = false;
    scaffold_elimination_status_[ScaffoldType::ExternalCurriculum] = false;
    scaffold_elimination_status_[ScaffoldType::PerformanceEvaluation] = false;
    scaffold_elimination_status_[ScaffoldType::TaskSpecification] = false;
    scaffold_elimination_status_[ScaffoldType::EnvironmentalSetup] = false;
}

void AutonomousLearningCycle::updateAutonomyMetrics() {
    std::lock_guard<std::mutex> lock(metrics_mutex_);
    
    // Update cycle counts
    metrics_.total_learning_cycles = cycle_count_.load();
    
    // Calculate autonomy metrics
    metrics_.intrinsic_motivation_dominance = calculateIntrinsicMotivationDominance();
    metrics_.self_initiated_task_ratio = calculateSelfInitiatedTaskRatio();
    
    // Calculate external dependency ratio
    std::size_t eliminated_scaffolds = 0;
    for (const auto& scaffold_pair : scaffold_elimination_status_) {
        if (scaffold_pair.second) {
            eliminated_scaffolds++;
        }
    }
    
    if (!scaffold_elimination_status_.empty()) {
        float elimination_ratio = static_cast<float>(eliminated_scaffolds) / scaffold_elimination_status_.size();
        metrics_.external_dependency_ratio = 1.0f - elimination_ratio;
    }
    
    // Count autonomous cycles (cycles with high autonomy)
    if (metrics_.current_autonomy_level > 0.8f) {
        metrics_.autonomous_cycles_completed++;
    }
    
    metrics_.last_assessment = std::chrono::steady_clock::now();
}

bool AutonomousLearningCycle::validatePerformanceMaintenance() const {
    if (performance_history_.empty()) return true;
    
    // Calculate recent performance average
    std::size_t recent_count = std::min(static_cast<std::size_t>(10), performance_history_.size());
    float recent_performance = 0.0f;
    
    for (std::size_t i = performance_history_.size() - recent_count; i < performance_history_.size(); ++i) {
        recent_performance += performance_history_[i];
    }
    recent_performance /= recent_count;
    
    // Check if performance is maintained above threshold
    float maintenance_ratio = recent_performance / std::max(baseline_performance_, 0.1f);
    return maintenance_ratio >= config_.performance_maintenance_threshold;
}

std::vector<std::string> AutonomousLearningCycle::generateIntrinsicObjectives() {
    std::vector<std::string> objectives;
    
    if (!brain_ || !task_generator_) return objectives;
    
    // Generate objectives based on substrate state
    float uncertainty = task_generator_->calculateUncertaintyLevel();
    float prediction_error = task_generator_->calculatePredictionError();
    float intrinsic_motivation = task_generator_->calculateIntrinsicMotivation();
    
    // Generate objectives based on current substrate needs
    if (uncertainty > 0.5f) {
        objectives.push_back("reduce_uncertainty_in_predictions");
    }
    
    if (prediction_error > 0.4f) {
        objectives.push_back("improve_prediction_accuracy");
    }
    
    if (intrinsic_motivation > 0.6f) {
        objectives.push_back("explore_novel_patterns");
    }
    
    // Always include self-improvement objective
    objectives.push_back("enhance_learning_efficiency");
    
    return objectives;
}

float AutonomousLearningCycle::implementSelfAssessment() {
    if (!brain_) return 0.0f;
    
    // Implement substrate-driven self-assessment
    float current_performance = monitorPerformanceDuringElimination();
    float autonomy_level = metrics_.current_autonomy_level;
    float learning_progress = 0.0f;
    
    // Calculate learning progress from performance history
    if (performance_history_.size() >= 2) {
        learning_progress = performance_history_.back() - performance_history_[performance_history_.size() - 2];
    }
    
    // Composite self-assessment score
    float self_assessment = (current_performance * 0.4f) + 
                           (autonomy_level * 0.4f) + 
                           (std::max(0.0f, learning_progress) * 0.2f);
    
    return std::clamp(self_assessment, 0.0f, 1.0f);
}

bool AutonomousLearningCycle::createAdaptiveLearningStrategies() {
    if (!task_generator_) return false;
    
    // Create adaptive strategies based on current substrate state
    auto& config = task_generator_->getConfig();
    
    // Adapt thresholds based on performance
    float performance = monitorPerformanceDuringElimination();
    
    if (performance < 0.5f) {
        // Lower thresholds to generate more learning opportunities
        // This would be implemented by modifying the task generator config
        return true;
    } else if (performance > 0.8f) {
        // Raise thresholds to focus on more challenging tasks
        return true;
    }
    
    return true;
}

} // namespace Core
} // namespace NeuroForge