## 2025-05-15 - [Windows Command Injection in shell_escape]
**Vulnerability:** The `shell_escape` function for Windows in `src/main.cpp` used `\"` to escape double quotes inside command arguments. However, `cmd.exe` does not treat `\"` as an escaped quote; it treats `"` as a toggle. This allowed attackers to break out of the quoted argument string using a double quote, leading to command injection via operators like `&`.
**Learning:** Windows `cmd.exe` argument parsing rules are inconsistent with C runtime `CommandLineToArgvW` rules. Safely escaping double quotes inside a double-quoted argument for `cmd.exe` is notoriously difficult and context-dependent.
**Prevention:** For file paths and simple strings on Windows, strictly forbid (throw exception) or strip double quotes rather than attempting to escape them. This is the only fail-safe way to prevent `cmd.exe` interpretation issues when using `std::system` or `cmd /c`.

## 2025-05-24 - [Flask-SocketIO Default CORS Permissiveness]
**Vulnerability:** `scripts/flask_app.py` intended to prevent cross-origin websocket hijacking (CSWSH) but used `SocketIO(app)` without arguments. By default, `python-socketio` (and thus `flask-socketio`) sets `cors_allowed_origins` to `None`, which allows ALL origins. This contradicted the code comments and security intent.
**Learning:** Security-critical libraries often prioritize ease of use over security by default. Always verify the default behavior of security-related parameters in documentation or by testing, rather than assuming a "secure default" exists.
**Prevention:** Explicitly configure `cors_allowed_origins` to a restricted list (e.g. `['http://127.0.0.1:port', 'http://localhost:port']`) when initializing `SocketIO` for internal/dashboard tools.

## 2025-05-25 - [Windows Shell Escape Trailing Backslash Injection]
**Vulnerability:** The `shell_escape` function for Windows in `src/main.cpp` correctly banned double quotes but failed to escape trailing backslashes. If an argument ended in a backslash (e.g., `C:\`), the resulting string `"C:\"` would cause the closing quote to be interpreted as a literal quote by the Windows C runtime (CommandLineToArgvW). This allowed the argument to "eat" subsequent arguments and potentially corrupt the command line structure passed to child processes like the viewer.
**Learning:** Banning dangerous characters is insufficient if the escape mechanism for the *quoting* characters itself is flawed. In Windows `cmd` and CRT parsing, trailing backslashes before a closing quote have special meaning (`\"` vs `\\"`).
**Prevention:** When wrapping arguments in quotes for Windows, always check for trailing backslashes and double them so they are treated as literal backslashes rather than escaping the closing quote.

## 2025-05-27 - [Windows Command Injection via std::system]
**Vulnerability:** `src/main.cpp` used `std::system("cmd /c start ...")` to launch the viewer process on Windows. Even with argument sanitization via `shell_escape`, relying on `cmd.exe` exposes the application to command injection risks if the escaping logic has subtle flaws or if future maintainers relax constraints. `cmd.exe` parsing is notoriously complex and difficult to secure completely.
**Learning:** The safest way to launch subprocesses on Windows is to bypass `cmd.exe` entirely. Using `CreateProcess` (or `CreateProcessA`/`CreateProcessW`) directly invokes the OS process creation API, which uses standard C runtime argument parsing (CommandLineToArgvW) that is much more predictable and secure than shell interpretation.
**Prevention:** Replace `std::system` calls with `CreateProcess` (Windows) or `posix_spawn`/`exec` (POSIX) whenever launching executables. This eliminates the shell as an attack surface.

## 2025-05-28 - [POSIX Command Injection Remediation]
**Vulnerability:** `src/main.cpp` used `std::system` on POSIX systems to launch the 3D viewer. This invoked `/bin/sh` and relied on `shell_escape` (wrapping in single quotes) to prevent command injection. While `shell_escape` for POSIX is simpler than Windows, relying on shell interpretation is inherently less secure than direct execution.
**Learning:** Even with robust escaping, `std::system` increases the attack surface. Refactoring to use `fork()` + `execvp()` eliminates the shell entirely, making argument passing deterministic and safe from injection attacks regardless of input characters. The double-fork pattern (fork -> waitpid(child1) + child1 fork -> exit -> child2 exec) effectively daemonizes the process without leaving zombies, replicating the behavior of `cmd &`.
**Prevention:** Prefer `exec` family functions over `system` or `popen` for launching external processes on POSIX. Use `posix_spawn` or `std::process` (if available in future standards/libraries) for simpler interfaces.
